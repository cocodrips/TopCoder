class ORSolitaireDiv2:
    def getMinimum(self, numbers, goal):
        numbers = list(numbers)
        numbers = list(sorted(numbers))

        goal_bin = str(bin(goal))[2:]
        goal_bin = list(reversed(goal_bin))

        counter = [0 for _ in goal_bin]
        numbers = [num for num in numbers if num <= goal]

        for num in numbers:
            num_bin = list(reversed(str(bin(num))[2:]))

            isInvalid = False
            for i, n in enumerate(num_bin):
                if goal_bin[i] == '0' and num_bin[i] == '1':
                    isInvalid = True
                    break
            if isInvalid:
                continue

            for i, n in enumerate(num_bin):
                if n == '1':
                    counter[i] += 1

        counter = [c for i, c in enumerate(counter) if goal_bin[i] == '1' ]

        return min(counter)









# BEGIN KAWIGIEDIT TESTING
# Generated by KawigiEdit-pfx 2.1.9
import sys
import time
def KawigiEdit_RunTest(testNum, p0, p1, hasAnswer, p2):
	sys.stdout.write(str("Test ") + str(testNum) + str(": [") + str("{"))
	for i in range(len(p0)):
		if (i > 0):
			sys.stdout.write(str(","))
		
		sys.stdout.write(str(p0[i]))
	
	sys.stdout.write(str("}") + str(",") + str(p1))
	print(str("]"))
	obj = ORSolitaireDiv2()
	startTime = time.clock()
	answer = obj.getMinimum(p0, p1)
	endTime = time.clock()
	res = True
	print(str("Time: ") + str((endTime - startTime)) + str(" seconds"))
	if (hasAnswer):
		print(str("Desired answer:"))
		print(str("\t") + str(p2))
	
	print(str("Your answer:"))
	print(str("\t") + str(answer))
	if (hasAnswer):
		res = answer == p2
	
	if (not res):
		print(str("DOESN'T MATCH!!!!"))
	elif ((endTime - startTime) >= 2):
		print(str("FAIL the timeout"))
		res = False
	elif (hasAnswer):
		print(str("Match :-)"))
	else:
		print(str("OK, but is it right?"))
	
	print(str(""))
	return res

all_right = True


# ----- test 0 -----
p0 = [1,2,4]
p1 = 7
p2 = 1
all_right = KawigiEdit_RunTest(0, p0, p1, True, p2) and all_right
# ------------------

# ----- test 1 -----
p0 = [1,2,4,7,8]
p1 = 7
p2 = 2
all_right = KawigiEdit_RunTest(1, p0, p1, True, p2) and all_right
# ------------------

# ----- test 2 -----
p0 = [12571295,2174218,2015120]
p1 = 1
p2 = 0
all_right = KawigiEdit_RunTest(2, p0, p1, True, p2) and all_right
# ------------------

# ----- test 3 -----
p0 = [5,2,4,52,62,9,8,3,1,11,6]
p1 = 11
p2 = 3
all_right = KawigiEdit_RunTest(3, p0, p1, True, p2) and all_right
# ------------------

# ----- test 4 -----
p0 = [503,505,152,435,491,512,1023,355,510,500,502,255,63,508,509,511,60,250,254,346]
p1 = 510
p2 = 5
all_right = KawigiEdit_RunTest(4, p0, p1, True, p2) and all_right
# ------------------

if (all_right):
	print(str("You're a stud (at least on the example cases)!"))
else:
	print(str("Some of the test cases had errors."))

# PROBLEM STATEMENT
# Note that the memory limit for all tasks in this SRM is 256 MB.
# This problem statement contains subscripts that may not display properly if viewed outside of the applet.
#
# Manao is playing a solitaire game called OR-solitaire. In this game, the player starts with a number X = 0 and should obtain the number goal in one or more moves. The set of valid moves is determined by a tuple (integer) numbers. In each move, the player chooses some element of numbers and replaces X with the bitwise OR of X and the chosen element.
#
# Fox Ciel wants Manao to stop playing OR-solitaire and move on with his life. She decided to erase some of the elements from numbers in such a way that it becomes impossible to complete the game. Return the minimum number of elements that need to be removed to achieve this.
#
# DEFINITION
# Class:ORSolitaireDiv2
# Method:getMinimum
# Parameters:tuple (integer), integer
# Returns:integer
# Method signature:def getMinimum(self, numbers, goal):
# 
# 
# NOTES
# -If a and b are single bits then a | b is defined as max(a, b). For two integers, A and B, in order to calculate A | B, they need to be represented in binary: A = (an...a1)2, B = (bn...b1)2 (if the lengths of their representations are different, the shorter one is prepended with the necessary number of leading zeroes). Then A | B = C = (cn...c1)2, where ci = ai | bi. For example, 10 | 3 = (1010)2 | (0011)2 = (1011)2 = 11.
# 
# 
# CONSTRAINTS
# -numbers will contain between 1 and 20 elements, inclusive.
# -Each element of numbers will be between 1 and 1,000,000,000.
# -The elements in numbers will be distinct.
# -goal will be between 1 and 1,000,000,000.
# 
# 
# EXAMPLES
# 
# 0)
# {1, 2, 4}
# 7
# 
# Returns: 1
# 
# The goal of the game is to obtain X = 7 from X = 0. The possible moves are to replace X with bitwise OR of X and 1, bitwise OR of X and 2 and bitwise OR of X and 4. X = 7 can be obtained only by using each of the three moves at least once, so removing any single element from numbers will make the game impossible to finish.
# 
# 1)
# {1, 2, 4, 7, 8}
# 7
# 
# Returns: 2
# 
# In this example, Fox Ciel should remove the number 7 and one of the numbers 1, 2, 4.
# 
# 2)
# {12571295, 2174218, 2015120}
# 1
# 
# Returns: 0
# 
# There is no need to remove elements from numbers, since the game cannot be completed in its initial version.
# 
# 3)
# {5, 2, 4, 52, 62, 9, 8, 3, 1, 11, 6}
# 11
# 
# Returns: 3
# 
# 
# 
# 4)
# {503, 505, 152, 435, 491, 512, 1023, 355, 510, 500, 502, 255, 63, 508, 509, 511, 60, 250, 254, 346}
# 510
# 
# Returns: 5
# 
# 
# 
# END KAWIGIEDIT TESTING

#Powered by KawigiEdit-pfx 2.1.9!
