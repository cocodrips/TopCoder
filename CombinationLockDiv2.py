import math
import string

class CombinationLockDiv2:
    def minimumMoves(self, S, T):
        hash = {0:0, 1:1, 2:2, 3:3, 4:4, 5:5, 6:4, 7:3, 8:2, 9:1}
        print hash
        sa = []
        for s, t in zip(S, T):
            sa.append(int(s) - int(t))
        print sa

        cnt = 0
        left = 0
        while left < len(sa):
            if sa[left] == 0:
                left += 1
                continue
            print 'left', left
            contri = 0
            most_contri = 0
            most_contri_roll = 0
            most_contri_right = left
            for right in xrange(left + 1, len(sa)):
                for roll in xrange(-4, 6):
                    for e in sa[left:right]:
                        contri += hash[e % 9] + hash[(e + roll) % 9]

                    print roll, contri
                    if most_contri < contri:
                        most_contri = contri
                        most_contri_roll = roll
                        most_contri_right = right
            print "roll!", most_contri_roll
            sa = sa[0:left] + [a + most_contri_roll for a in sa[left:most_contri_right]] + sa[most_contri_right:]

            cnt += abs(most_contri_roll)

            print sa







        return cnt

# BEGIN KAWIGIEDIT TESTING
# Generated by KawigiEdit-pfx 2.1.9
import sys
import time
def KawigiEdit_RunTest(testNum, p0, p1, hasAnswer, p2):
	sys.stdout.write(str("Test ") + str(testNum) + str(": [") + str("\"") + str(p0) + str("\"") + str(",") + str("\"") + str(p1) + str("\""))
	print(str("]"))
	obj = CombinationLockDiv2()
	startTime = time.clock()
	answer = obj.minimumMoves(p0, p1)
	endTime = time.clock()
	res = True
	print(str("Time: ") + str((endTime - startTime)) + str(" seconds"))
	if (hasAnswer):
		print(str("Desired answer:"))
		print(str("\t") + str(p2))
	
	print(str("Your answer:"))
	print(str("\t") + str(answer))
	if (hasAnswer):
		res = answer == p2
	
	if (not res):
		print(str("DOESN'T MATCH!!!!"))
	elif ((endTime - startTime) >= 2):
		print(str("FAIL the timeout"))
		res = False
	elif (hasAnswer):
		print(str("Match :-)"))
	else:
		print(str("OK, but is it right?"))
	
	print(str(""))
	return res

all_right = True


# ----- test 0 -----
p0 = "123"
p1 = "112"
p2 = 1
all_right = KawigiEdit_RunTest(0, p0, p1, True, p2) and all_right
# ------------------

# ----- test 1 -----
p0 = "1"
p1 = "7"
p2 = 4
all_right = KawigiEdit_RunTest(1, p0, p1, True, p2) and all_right
# ------------------

# ----- test 2 -----
p0 = "607"
p1 = "607"
p2 = 0
all_right = KawigiEdit_RunTest(2, p0, p1, True, p2) and all_right
# ------------------

# ----- test 3 -----
p0 = "1234"
p1 = "4567"
p2 = 3
all_right = KawigiEdit_RunTest(3, p0, p1, True, p2) and all_right
# ------------------

# ----- test 4 -----
p0 = "020"
p1 = "909"
p2 = 2
all_right = KawigiEdit_RunTest(4, p0, p1, True, p2) and all_right
# ------------------

# ----- test 5 -----
p0 = "4423232218340"
p1 = "6290421476245"
p2 = 18
all_right = KawigiEdit_RunTest(5, p0, p1, True, p2) and all_right
# ------------------

if (all_right):
	print(str("You're a stud (at least on the example cases)!"))
else:
	print(str("Some of the test cases had errors."))

# PROBLEM STATEMENT
# Andrew has a combination lock.
# The lock consists of multiple dials that are placed next to each other.
# Each dial contains the digits 0 through 9, in order.
# At any moment, exactly one of the digits on each dial is visible.
# The string formed by the currently visible digits is called the current combination.
#
# The visible digit on a dial can be changed by rotating the dial up or down.
# Rotating the dial up changes 0 to 1, 1 to 2, and so on.
# Note that the digits on a dial wrap around: if we rotate up a dial that shows a 9, it will show a 0 again.
# Naturally, rotating the dial down changes the digit in the other direction.
#
# We are able to rotate multiple dials at the same time, as long as they are next to each other.
# More precisely, in a single turn we can take an arbitrarily long segment of consecutive dials, and rotate all of them one step in the same direction (i.e., either all of them up, or all of them down).
#
# For example, suppose that the current combination is "123".
# In one step, we can change it to many different combinations, including "012" (all three dials down), "234" (all three dials up), "133" (middle dial up), and "013" (first two dials down).
# Note that we cannot change "123" to "224" in a single step.
#
# You are given two strings: S and T.
# S is the current combination, T is the secret combination that unlocks the lock.
# That is, to open the lock we need to change S into T by rotating some of the dials.
# Return the smallest number of steps needed.
#
# DEFINITION
# Class:CombinationLockDiv2
# Method:minimumMoves
# Parameters:string, string
# Returns:integer
# Method signature:def minimumMoves(self, S, T):
# 
# 
# CONSTRAINTS
# -S will contain between 1 and 50 characters, inclusive.
# -S will contain the same number of characters as T.
# -Each character in S and T will be a digit ('0'-'9').
# 
# 
# EXAMPLES
# 
# 0)
# "123"
# "112"
# 
# Returns: 1
# 
# Rotate the last two dials down.
# 
# 1)
# "1"
# "7"
# 
# Returns: 4
# 
# Rotate the dial down 4 times: from 1 to 0, from 0 to 9, from 9 to 8, and from 8 to 7.
# 
# 2)
# "607"
# "607"
# 
# Returns: 0
# 
# 
# 
# 3)
# "1234"
# "4567"
# 
# Returns: 3
# 
# 
# 
# 4)
# "020"
# "909"
# 
# Returns: 2
# 
# 
# 
# 5)
# "4423232218340"
# "6290421476245"
# 
# Returns: 18
# 
# 
# 
# END KAWIGIEDIT TESTING
#Powered by KawigiEdit-pfx 2.1.9!
