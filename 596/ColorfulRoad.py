import math
import string

class ColorfulRoad:
    DEFAULT = 1000000
    def getMin(self, road):
        memo = [-1 for i in xrange(len(road))]
        ans =  self.f(road, 0, memo)
        if ans < self.DEFAULT:
            return ans
        return -1

    def f(self, road, n, memo):
        N = len(road)
        if n == N - 1:
            return 0
        if memo[n] != -1:
            return memo[n]
        memo[n] = self.DEFAULT
        for i in xrange(n + 1, N):
            if self.canJump(road[n], road[i]):
                memo[n] = min(memo[n], self.power(i, n) + self.f(road, i, memo))
        return memo[n]

    def canJump(self, step, next):
        list = ['R','G','B']
        for i in xrange(len(list)):
            if step == list[i] and next == list[(i+1)%len(list)]:
                return True
        return False

    def power(self, p, n):
        return (n-p) * (n-p)



    # def f(n):
    #     tired = 0
    #     list = ['R','G','B']
    #     c = 0
    #     prev = 0
    #     for index, step in enumerate(road):
    #         next = list[(c+1) % 3]
    #         if step == next:
    #             c = (c+1) % 3
    #
    #             start = index
    #             end = index
    #             if step == next:
    #                 for oo, r in enumerate(road[index::]):
    #                     if index + oo < len(road)-1:
    #                         if road[index + oo] == next:
    #                             end = index + oo
    #                         else:
    #                             break
    #                     if index + oo  == len(road) - 1:
    #                         if road[index + oo ] == next:
    #                             tired += pow(index - prev, 2)
    #                             return tired
    #
    #             tired += pow(int((start+end)/2) - prev, 2)
    #             prev = int((start+end)/2)
    #     else:
    #         return -1





# BEGIN KAWIGIEDIT TESTING
# Generated by KawigiEdit-pfx 2.1.9
import sys
import time
def KawigiEdit_RunTest(testNum, p0, hasAnswer, p1):
	sys.stdout.write(str("Test ") + str(testNum) + str(": [") + str("\"") + str(p0) + str("\""))
	print(str("]"))
	obj = ColorfulRoad()
	startTime = time.clock()
	answer = obj.getMin(p0)
	endTime = time.clock()
	res = True
	print(str("Time: ") + str((endTime - startTime)) + str(" seconds"))
	if (hasAnswer):
		print(str("Desired answer:"))
		print(str("\t") + str(p1))
	
	print(str("Your answer:"))
	print(str("\t") + str(answer))
	if (hasAnswer):
		res = answer == p1
	
	if (not res):
		print(str("DOESN'T MATCH!!!!"))
	elif ((endTime - startTime) >= 2):
		print(str("FAIL the timeout"))
		res = False
	elif (hasAnswer):
		print(str("Match :-)"))
	else:
		print(str("OK, but is it right?"))
	
	print(str(""))
	return res

all_right = True


# ----- test 0 -----
p0 = "RGGGB"
p1 = 8
all_right = KawigiEdit_RunTest(0, p0, True, p1) and all_right
# ------------------

# ----- test 1 -----
p0 = "RGBRGBRGB"
p1 = 8
all_right = KawigiEdit_RunTest(1, p0, True, p1) and all_right
# ------------------

# ----- test 2 -----
p0 = "RBBGGGRR"
p1 = -1
all_right = KawigiEdit_RunTest(2, p0, True, p1) and all_right
# ------------------

# ----- test 3 -----
p0 = "RBRRBGGGBBBBR"
p1 = 50
all_right = KawigiEdit_RunTest(3, p0, True, p1) and all_right
# ------------------

# ----- test 4 -----
p0 = "RG"
p1 = 1
all_right = KawigiEdit_RunTest(4, p0, True, p1) and all_right
# ------------------

# ----- test 5 -----
p0 = "RBRGBGBGGBGRGGG"
p1 = 52
all_right = KawigiEdit_RunTest(5, p0, True, p1) and all_right
# ------------------

if (all_right):
	print(str("You're a stud (at least on the example cases)!"))
else:
	print(str("Some of the test cases had errors."))

# PROBLEM STATEMENT
# 
# There is a one-dimensional road.
# The road is separated into N consecutive parts.
# The parts are numbered 0 through N-1, in order.
# Ciel is going to walk from part 0 to part N-1.
#
#
# Ciel also noticed that each part of the road has a color: either red, green, or blue.
# Part 0 is red.
#
#
# Ciel is going to perform a sequence of steps.
# Each step must lead in the positive direction.
# That is, if her current part is i, the next step will take her to one of the parts i+1 through N-1, inclusive.
# Her steps can be arbitrarily long.
# However, longer steps are harder: a step of length j costs j*j energy.
#
#
# Additionally, Ciel wants to step on colors in a specific order: red, green, blue, red, green, blue, ...
# That is, she starts on the red part 0, makes a step to a green part, from there to a blue part, and so on, always repeating red, green, and blue in a cycle.
# Note that the final part N-1 also has some color and thus Ciel must reach it in a corresponding step.
#
#
# You are given a string road containing N elements.
# For each i, element i of road is the color of part i: 'R' represents red, 'G' green, and 'B' blue.
# If Ciel can reach part N-1 in the way described above, return the smallest possible total cost of doing so.
# Otherwise, return -1.
# 
# 
# 
# DEFINITION
# Class:ColorfulRoad
# Method:getMin
# Parameters:string
# Returns:integer
# Method signature:def getMin(self, road):
# 
# 
# CONSTRAINTS
# -road will contain between 2 and 15 characters, inclusive.
# -Each character of road will be either 'R' or 'G' or 'B'.
# -The first character of road will be 'R'.
# 
# 
# EXAMPLES
# 
# 0)
# "RGGGB"
# 
# Returns: 8
# 
# The optimum solution is to step part 0 -> part 2 -> part 4.
# The total cost is 2*2 + 2*2 = 8.
# 
# 1)
# "RGBRGBRGB"
# 
# Returns: 8
# 
# The optimum solution is to make steps of length 1.
# It costs 1*1 = 1 per each step, so the total cost is 8.
# 
# 2)
# "RBBGGGRR"
# 
# Returns: -1
# 
# It is impossible to reach the destination.
# 
# 
# 3)
# "RBRRBGGGBBBBR"
# 
# Returns: 50
# 
# 
# 
# 4)
# "RG"
# 
# Returns: 1
# 
# 
# 
# 5)
# "RBRGBGBGGBGRGGG"
# 
# Returns: 52
# 
# 
# 
# END KAWIGIEDIT TESTING

#Powered by KawigiEdit-pfx 2.1.9!
